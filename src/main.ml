(* OPythn main front-end *)

open Printf

exception File_error of string

(* opens the specified file and outputs its contents as a string *)
let str_from_filename filename =
  try
    let ch = open_in filename in
    let size = in_channel_length ch in
    let str = really_input_string ch size in
    close_in ch;
    Some str
  with e -> None

(* print tokens generated by lexer *)
let print_lex buffer =
  let tok = ref (Lexer.read buffer) in
  while !tok <> EOF do
    printf "%s" (Token.show !tok);
    tok := (Lexer.read buffer)
  done;
  printf "%s" (Token.show !tok)

(* return printable AST generated by parser *)
let parse buffer = try Parser.input Lexer.read buffer with
                     Parser.Error ->
                       printf "%s: Syntax error.\n" (Lexer.print_position buffer); []

(* run tests *)
let run_tests opy_code =
  let buffer = ref (Lexing.from_string opy_code) in
  printf "************ LEXER OUTPUT ************\n";
  Lexer.setup_file_input !buffer;
  print_lex !buffer;
  printf "************ PARSER OUTPUT ************\n";
  buffer := Lexing.from_string opy_code; (* reset buffer *)
  Lexer.setup_file_input !buffer;
  let tree = parse !buffer in
  printf "%s\n" (Ast.show tree);
  printf "************ BYTECODE ************\n";
  let instrs = Bytecode.compile_prog tree in
  Bytecode.print_asm instrs
(*   printf "************ CONSOLE OUTPUT ************\n"; *)
(*   Interpreter.interpret instrs @@ Interpreter.init_env () *)

(* normal file input *)
let from_file opy_code =
  let buffer = Lexing.from_string opy_code in
  Lexer.setup_file_input buffer;
  let tree = parse buffer in
  let instrs = Bytecode.compile_prog tree in
  Interpreter.interpret instrs @@ Interpreter.init_env ()

(* quit repl *)
let quit _ =
  printf "\nIch sterbe.\n";
  exit 0

(* read-eval-print loop *)
let rec repl envr =
  try
    printf "]=> ";
    flush stdout;
    let buffer = Lexing.from_channel stdin in
    Lexer.setup_repl_input buffer;
    let tree = parse buffer in
    printf "************ PARSER OUTPUT ************\n";
    printf "%s\n" (Ast.show tree);
    printf "************ BYTECODE ************\n";
    let instrs = Bytecode.compile_prog tree in
    Bytecode.print_asm instrs;
    printf "************ CONSOLE OUTPUT ************\n";
    Interpreter.interpret instrs envr;
    repl envr
  with e ->
    let msg = Printexc.to_string e in
    printf "Error: %s\n" msg;
    repl envr

(* currently prints lex output only *)
let rec debug () =
  printf "DEBUG]=> ";
  flush stdout;
  let buffer = Lexing.from_channel stdin in
  Lexer.setup_repl_input buffer;
  printf "************ LEXER OUTPUT ************\n";
  print_lex buffer;
  debug ()

let handle_file (debug : bool) filename =
  let proc = if debug then run_tests else from_file in
  if Filename.extension filename <> ".opy" then
    raise (File_error "File extension not supported.")
  else
    match str_from_filename filename with
      Some s -> proc s
    | None   -> printf "Failed to read from file.\n"

(* select mode based on program arguments *)
let main () =
  Sys.set_signal Sys.sigint (Sys.Signal_handle quit);
  let argc = Array.length Sys.argv in
  if argc < 2 then (
    (* start interactive mode *)
    printf "+----------------------------------------------+\n";
    printf "|             OPYTHN INTERACTIVE MODE          |\n";
    printf "|   Author: Marcel Goh (Release: 30.04.2019)   |\n";
    printf "|            Type \"Ctrl-C\" to quit.            |\n";
    printf "+----------------------------------------------+\n";
    flush stdout;
    let envr = Interpreter.init_env () in
    repl envr
  )
  else
    if Sys.argv.(1) = "-debug" then (
      if argc > 2 then
        (* run file with all outputs *)
        handle_file true Sys.argv.(2)
      else (
        printf "Entering debug mode.\n";
        (* start debug REPL *)
        debug()
      )
    )
    else
      (* run file normally *)
      handle_file false Sys.argv.(1)

let () = main ()
