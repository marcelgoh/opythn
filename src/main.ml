(* OPythn main front-end *)

open Printf

exception File_error of string

(* command-line flags *)
let debug = ref false         (* print intermediary outputs *)
let lex = ref false           (* lex-only mode *)
let load = ref ""             (* load code into REPL from files *)
let filename = ref None       (* filename *)

let set_file_to_load str = load := str
let do_nothing () = ()
(* only the first anonymous argument is saved as filename *)
let set_filename str =
  match !filename with
    None -> filename := Some str
  | Some _ -> ()

let usage_msg = "Available options:"

let speclist = [
  ("-debug", Arg.Set debug, "\tEnables printing of all intermediary representations");
  ("-lex", Arg.Set lex, "\tStarts REPL in lex-only mode");
  ("-load", Arg.String set_file_to_load, "\tStarts REPL with a file loaded");
]

(* pointer to global environment *)
let envr = ref (Interpreter.init_env ())

(* opens the specified file and outputs its contents as a string *)
let str_from_filename fname =
  try
    let ch = open_in fname in
    let size = in_channel_length ch in
    let str = really_input_string ch size in
    close_in ch;
    Some str
  with e -> None

(* print tokens generated by lexer *)
let print_lex buffer =
  let tok = ref (Lexer.read buffer) in
  while !tok <> EOF do
    printf "%s" (Token.show !tok);
    tok := (Lexer.read buffer)
  done;
  printf "%s" (Token.show !tok)

(* return printable string of offending line/column *)
let get_line_col buffer =
  let colon_r = Str.regexp_string ":" in
  let str = Lexer.print_position buffer in
  let line_label = Str.replace_first colon_r "line " str in
  Str.replace_first colon_r ", column " line_label


(* file input *)
let from_file opy_code =
  let buffer = ref (Lexing.from_string opy_code) in
  try
    if !debug then (
      printf "************* LEXER OUTPUT *************\n";
      Lexer.setup_file_input !buffer;
      print_lex !buffer;
      buffer := Lexing.from_string opy_code (* reset buffer *)
    );
    Lexer.setup_file_input !buffer;
    let tree = Parser.input Lexer.read !buffer in
    let instrs = Bytecode.compile_prog false tree in
    if !debug then (
      printf "************ PARSER OUTPUT *************\n";
      printf "%s\n" (Ast.show tree);
      printf "*************** BYTECODE ***************\n";
      Bytecode.print_asm instrs;
      printf "************ CONSOLE OUTPUT ************\n"
    );
    envr := Interpreter.interpret instrs !envr 
  with
    Parser.Error ->
      printf "Syntax error at %s.\n" (get_line_col !buffer)
  | e ->
      let msg = Printexc.to_string e in
      printf "Error: %s.\n" msg

(* quit repl *)
let quit _ =
  printf "\nIch sterbe.\n";
  exit 0

(* read-eval-print loop *)
let rec repl () =
  printf "]=> ";
  flush stdout;
  let buffer = Lexing.from_channel stdin in
  try
    Lexer.setup_repl_input buffer;
    let tree = Parser.input Lexer.read buffer in
    let instrs = Bytecode.compile_prog true tree in
    if !debug then (
      printf "************ PARSER OUTPUT *************\n";
      printf "%s\n" (Ast.show tree);
      printf "*************** BYTECODE ***************\n";
      Bytecode.print_asm instrs;
      printf "************ CONSOLE OUTPUT ************\n"
    );
    (* interpret instructions and update global environment pointer *)
    envr := Interpreter.interpret instrs !envr;
    repl ()
  with
    Parse_errors.Eof_found ->
      quit ()
  | Parser.Error ->
      printf "Syntax error at %s.\n" (get_line_col buffer);
      repl ()
  | Sys.Break ->
      raise Sys.Break
  | e ->
      let msg = Printexc.to_string e in
      printf "Error: %s.\n" msg;
      repl ()

(* currently prints lex output only *)
let rec lex_only () =
  printf "LEX-ONLY]=> ";
  flush stdout;
  let buffer = Lexing.from_channel stdin in
  Lexer.setup_repl_input buffer;
  printf "************* LEXER OUTPUT *************\n";
  print_lex buffer;
  lex_only ()

let handle_file filename =
  if Filename.extension filename <> ".opy" then
    raise (File_error "File extension not supported.")
  else
    match str_from_filename filename with
      Some s -> from_file s
    | None   -> printf "Failed to read from file.\n"

let handle_interactive () =
  (* start interactive mode *)
  if !lex then (
    lex_only ()
  )
  else (
    if !load <> "" then (
      handle_file !load
    );
    repl ()
  )

let read_one_char () =
    let termio = Unix.tcgetattr Unix.stdin in
    Unix.tcsetattr Unix.stdin Unix.TCSADRAIN { termio with Unix.c_icanon = false };
    let c = input_char stdin in
    Unix.tcsetattr Unix.stdin Unix.TCSADRAIN termio;
    c

(* behaviour on interrupt *)
let rec ctrlc () =
  try (
    printf "\nInterrupted. Enter option (? for help): ";
    flush stdout;
    let c = read_one_char () in
    flush stdout;
    printf "\n";
    match c with
      'd' | 'D' ->
        debug := not !debug;
        handle_interactive ()
    | 'i' | 'I' ->
        handle_interactive()
    | 'l' | 'L' ->
        lex := not !lex;
        handle_interactive ()
    | 'q' | 'Q' ->
        printf "Ich sterbe.\n";
        exit 0
    | 'r' | 'R' ->
        envr := Interpreter.init_env ();
        handle_interactive ()
    | '?' ->
        printf "\nD: Toggle debug mode.\n";
        printf "I: Ignore interrupt request.\n";
        printf "L: Toggle lex-only mode.\n";
        printf "Q: Quit the REPL.\n";
        printf "R: Reset REPL with empty environment.\n";
        ctrlc ()
    | _ ->
        printf "\nUnknown option.\n";
        ctrlc ()
  )
  with Sys.Break -> ctrlc ()

let print_splash () =
  printf "+----------------------------------------------+\n";
  printf "|            OPYTHN INTERACTIVE MODE           |\n";
  printf "|   Author: Marcel Goh (Release: 12.06.2019)   |\n";
  printf "|          Type \"Ctrl-C\" for options.          |\n";
  printf "+----------------------------------------------+\n"

(* program entry point *)
let main () =
  try (
    Arg.parse (Arg.align speclist) set_filename usage_msg;
    if !lex || !load <> "" then (
      print_splash ();
      Sys.catch_break true;
      handle_interactive ()
    )
    else (
      match !filename with
        None ->
          print_splash ();
          Sys.catch_break true;
          handle_interactive ()
      | Some fname ->
          handle_file fname;
          exit 0
    )
  )
  with Sys.Break -> ctrlc ()

let () = main ()
