\input fontmac
\input mathmac

\def\thing{\item{$\bullet$}}
\def\tab{\ \ \ \ }
\def\Procedure{{\bf procedure} }
\def\While{{\bf while} }
\def\Begin{{\bf begin}}
\def\If{{\bf if} }
\def\Then{{\bf then} }
\def\Do{{\bf do} }
\def\For{{\bf for} }
\def\ElsIf{{\bf else if} }
\def\Return{{\bf return} }
\def\EndWhile{{\bf end while} }
\def\EndIf{{\bf end if}}
\def\EndFor{{\bf end for}}
\def\EndProcedure{{\bf end procedure}}
\def\littlespace{\hskip5pt}
\def\_{\char'137}

\maketitle{The OPythn programming language}{by}{Marcel K. Goh}{\sl McGill University}

\floattext5 Note. {\sl This report was written as part of an NPRG045 Individual Software Project for the Summer 2019
term at Charles University in Prague. The author would like to thank Adam Dingle for his willingness to
supervise an exchange student, and for his careful supervision
and constant encouragement.}

% INTRODUCTION
\advsect INTRODUCTION

The OPythn project implements a working subset of the Python programming language by means of a bytecode compiler and interpreter, written in OCaml. Users will be able to interact with OPythn via a top-level read-eval-print loop or interpret OPythn source code directly from a file. This report will consist of a specification of the interpreter and the OPythn language, followed by a brief description of the implementation.

% GETTING STARTED
\advsect GETTING STARTED

OPythn should work on Unix/Linux operating systems. OPythn's source code requires that an installation of OCaml be present on the system in order to compile. In addition, the following packages are needed:
\medskip
\thing {\tt extlib}
\smallskip
\thing {\tt menhir}
\smallskip
\thing {\tt ppx\_deriving}
\medskip
\noindent The user may find it convenient to use OPAM, OCaml's package manager. All required packages can be installed via OPAM by running {\tt opam install extlib menhir ppx\_deriving}. Once this is set up, running {\tt make} from the main OPythn directory compiles the program. To delete files generated by Make, run {\tt make clean}.

\section 2.1. Usage

Once compiled, OPythn can be started using commands of the format {\tt ./main [options] [filename]} from the main {\tt opythn} directory. A list of valid command-line options can be displayed by running {\tt ./main --help}. Calling the program with no options or file arguments starts the REPL (read-eval-print loop) with default options.
\begincode
+----------------------------------------------+
|            OPYTHN INTERACTIVE MODE           |
|   Author: Marcel Goh (Release: 24.VI.2019)   |
|          Type "Ctrl-C" for options.          |
+----------------------------------------------+
]=>
\endcode
In the REPL, the user can enter OPythn statements line-by-line for the interpreter to evaluate. The REPL saves the environment between inputs. Entering {\tt Ctrl-C} interrupts the REPL and opens a menu from which the user can set options, clear the current environment, or exit the program.

Another way to run OPythn source code is to enter an entire program into a plain-text editor and save it as a file with the extension {\tt .opy}. Then running {\tt ./main <filename>} from the command-line interprets the code and produces the specified program behaviour. Simple examples of OPythn programs are included in the {\tt examples} folder.

% LANGUAGE
\advsect THE OPYTHN PROGRAMMING LANGUAGE

This section describes the OPythn language. To avoid repeating too much of the Python specification, it is assumed that the reader has basic familiarity with Python.

\section 3.1. Lexical conventions

The OPythn interpreter reads source code as ASCII characters, which are fed into a lexer. The following is a brief outline of the input that the interpreter expects.

\medskip
\boldlabel 3.1.1{.}\enspace Line and block structure.
The end of a line is represented by the {\tt NEWLINE} token. In general, simple statements cannot be split over multiple lines. However, an expression in parentheses, square brackets, or curly braces can be written over multiple lines without ending the statement. The {\tt \#} character can be used to indicate comments in source code. Any letters from {\tt \#} to the end of the line will be ignored by the lexer. A line that contains only whitespaces or comments is ignored by the lexer except during interactive evaluation, when a blank line is used to indicate the end of a multi-line statement.

\medskip
\boldlabel 3.1.2{.}\enspace Keywords and identifiers.
The following are OPythn keywords and cannot be used in ordinary identifiers:
$$\matrix{
{\tt True} & {\tt False} & {\tt None} & {\tt and} & {\tt or} & {\tt not}\cr
{\tt if} & {\tt elif} & {\tt else} & {\tt for} & {\tt in} & {\tt while}\cr
{\tt break} & {\tt continue} & {\tt class} & {\tt is} & {\tt del} & {\tt pass}\cr
{\tt in} & {\tt def} &{\tt global} & {\tt nonlocal} & {\tt lambda} & \cr
}$$
Any string that is not a keyword and contains uppercase and lowercase letters, underscores, and (except for the first character) numbers is a valid identifier. Case is significant. Some names are used by OPythn's standard library functions, which are further described in Section 3.2.7.

\medskip
\boldlabel 3.1.3{.}\enspace Literals.
Strings are enclosed in matching single quotes or double quotes. Triple-quoted strings are not supported, nor are formatted string literals. The backslash character {\tt \textbackslash} is used to escape certain characters such as tabs and newlines.

There are two types of numeric literals in OPythn: integers and floating-point numbers. Leading zeroes in a non-zero decimal integer are not allowed. Underscores are also not allowed in numeric literals, unlike in Python 3. Floating-point literals are supported, but must be supplied in point form and not in scientific notation.
\begincode
integer: '-'? ['1'-'9'] ['0'-'9']* | '-'? '0'*
pointfloat: '-'? ['0'-'9']* '.' ['0'-'9']* | ['0'-'9']+ '.'
\endcode

\medskip
\boldlabel 3.1.4{.}\enspace Operators and delimiters.
All symbolic operators and delimiters are inherited from standard Python except the {\tt @} and {\tt @=} symbols. (They are used for matrix multiplication and decorators, both of which are not features of OPythn.)

% LANGUAGE
\section 3.2. Language

The core of OPythn is designed to be lightweight and minimal. Basic types and operations, control structures, and elementary data structures are included, while more complex Python constructions, such as comprehensions, generators, and coroutines are omitted.

\medskip
\boldlabel 3.2.1{.}\enspace Simple and compound types.
Every value in OPythn is of a certain type. There are four primitive types ({\tt int}, {\tt float}, {\tt str}, and {\tt bool}) and all of them are immutable. Integers are represented with 63 bits and can range between $-4,611,686,018,427,387,904$ and $4,611,686,018,427,387,903$ inclusive. Strings contain 8-bit characters.

OPythn has three compound types: {\tt list}, {\tt dict}, and {\tt tuple}. Of these, only tuples are immutable. Lists are zero-indexed and accessing an element via its index takes constant time. Dictionaries support values of different types. For example, {\tt d = {2: 'bonjour', False: 3.3}} is a valid OPythn dictionary.
   
\medskip\boldlabel 3.2.2{.}\enspace Numeric and boolean operations.
Ordinary arithmetic operators for addition, multiplication, subtraction, division, modulus, and exponentiation are supported between types {\tt int} and {\tt float}. When performing integer division, OPythn takes the floor of the quotient, so {\tt -13 // 5} gives {\tt -3}, and the modulus operator always gives a positive result, so {\tt -13 \% 5} returns {\tt 2}.

OPythn supports the bitwise operations {\tt |}, {\tt \char`137}, {\tt \&}, {\tt <<}, {\tt >>}, and {\tt `176} on integers. Numeric values can be compared using the operators {\tt <}, {\tt <=}, {\tt >}, and {\tt >=} (chained comparisons are not allowed), and any values can be tested for equality using {\tt ==}, {\tt !=}, {\tt is}, and {\tt is not}. Any object can be tested for truth value. The objects {\tt None}, {\tt False}, {\tt 0}, {\tt 0.0}, {\tt ''}, {\tt []}, and {\tt \string{\string}} are considered false; any other object is considered true.

\medskip\boldlabel 3.2.3{.}\enspace String operations.
The following useful methods are defined on strings, along with all of the methods on sequence types described in the following subsection.
$$\matrix{
        {\tt find()} & {\tt isalpha()} & {\tt isdigit()} & {\tt islower()} & {\tt isupper()}\cr
}$$

\medskip\boldlabel 3.2.4{.}\enspace Operations on sequence types.
Strings, lists, and tuples are considered sequence types in OPythn and support a number of useful operations.
\medskip
\thing The element at a given index can be accessed using the postfix {\tt [ ]} operator. The expression inside must be an integer. Negative indices are allowed. For example, if {\tt x} is the list {\tt [1,2,3,4]}, then {\tt x[-2]} will return {\tt 3}. Indexing into a list is the normal way to mutate a value. For example, running the expression {\tt x[1] = 'grape'} changes {\tt x} into the list {\tt [1,'grape',3,4]}. This cannot be done with tuples because they are immutable.
\smallskip
\thing The number of elements in the sequence (characters, in the case of strings) can be determined using the built-in function {\tt len()}.
\smallskip
\thing To determine if a sequence {\tt l} contains the element {\tt e}, one may use the expression {\tt e in l} which returns the corresponding boolean. When used with a {\tt for} loop, this syntax allows the user to iterate through all the elements in a list. To see if an element does not belong to a list, one may use {\tt not in}, but of course this cannot be used to create a {\tt for} loop. The {\tt enumerate} object does not exist in OPythn.
\smallskip
\thing Sequence objects can be sliced using the operator {\tt :}. For example, if {\tt a = [1,True,3,'hi',5]}, then {\tt a[1:3]} would give the list {\tt [True, 3]}. This can be used with the {\tt del} keyword to delete a group of adjacent elements in a sequence. Slicing in step increments is not supported and a {\tt slice} object cannot be explicitly created.
\smallskip
\thing Sequences of the same type can be concatenated using the {\tt +} operator.
\smallskip
\thing A sequence can be explicitly converted into a list by calling {\tt list()} on it. (Calling {\tt list()} on a list returns the same list.)
\medskip
There are no list methods in OPythn. Because concatenation is performed in amortized constant time, the user may find it convenient to append to or extend a list by using the syntax {\tt list += [new1, new2, ...]}. In addition, OPythn supports the special method {\tt range()}, which behaves as in Python when called with one, two, or three arguments.

\medskip\boldlabel 3.2.5{.}\enspace Operations on dictionaries.
The following operations are defined on dictionaries.
\medskip
\thing Accessing an element can be done using the syntax {\tt dict[key]}. New entries can be added by running {\tt dict[new\_key] = new\_value}, but duplicate keys are not allowed, so if an entry already exists with the same key, it will be replaced with the new key-value pair.
\smallskip
\thing An entry can be deleted using the syntax {\tt del dict[key]} and the entire dictionary can be deleted by calling {\tt del} on the whole dictionary.
\smallskip
\thing The user can determine if a key is present in a dictionary using {\tt in} or {\tt not in}.
\medskip
Note that two dictionaries are equal if they contain the same keys and values. The following methods are defined on dictionary objects.
$$\matrix{
{\tt clear()} & {\tt items()} & {\tt keys()} & {\tt values()}\cr
}$$

\medskip\boldlabel 3.2.6{.}\enspace Branching structures.
OPythn inherits the control structures {\tt if}, {\tt for}, and {\tt while} from Python. Like in Python, consecutive lines at the same indentation level belong to the same block. Conditional expressions of the form {\tt <expr> if <condition> else <expr>} are also valid.

\medskip\boldlabel 3.2.7{.}\enspace Functions.
OPythn supports higher-order functions and nested functions. In OPythn, functions cannot modify variables outside their scope, unless one of the keywords {\tt global} or {\tt nonlocal} is used. OPythn supports anonymous functions using the keyword {\tt lambda}. OPythn functions take positional arguments only, and specifying default values is not allowed.

The following functions, implemented ``under the hood'' in OCaml, comprise OPythn's standard library and are included in a normal installation.
$$\matrix{
{\tt abs()} & {\tt bin()} & {\tt bool()} & {\tt chr()} & {\tt float()} & {\tt hex()}\cr
{\tt input()} & {\tt isinstance()} & {\tt issubclass()} & {\tt int()} & {\tt len()} & {\tt oct()}\cr
{\tt ord()} & {\tt print()} & {\tt range()} & {\tt round()} & {\tt str()} & {\tt type()}
}$$

\medskip\boldlabel 3.2.8{.}\enspace Classes and objects.
OPythn is object-oriented and allows the user to define classes. Multiple inheritance are not supported. When creating a class, the following special methods can be added to indicate how the class should behave: {\tt \_\_init\_\_()}, {\tt \_\_eq\_\_()}. The {\tt \_\_ne\_\_()} method is not supported, as {\tt e1 != e2} is always equivalent to {\tt not (e1 == e2)} in OPythn.

OPythn does not allow private attributes and methods. In general, an object's attributes and methods can be accessed and mutated by functions outside the class' definition. All Python values are objects, but the user is not allowed to subclass built-in types.
\medskip\boldlabel 3.2.9{.}\enspace Error handling.
OPythn does not include support for exceptions. When an error occurs, the program prints an error message and either terminates or returns to the REPL.

% IMPLEMENTATION
\advsect IMPLEMENTATION

Both the OPythn bytecode compiler and interpreter will be implemented in OCaml. This section gives a rough overview of the process by which OPythn source code is handled and executed. The modules mentioned in this section can be found in the {\tt src} folder of the OPythn repository.

\section 4.1. Lexical analysis

Upon reading source code, the OPythn front-end passes the data as a string to a series of functions that lex the code into tokens. The lexer will be created with the help of {\tt ocamllex}, a program that generates a finite state machine in OCaml. This resulting lexer matches regular expressions in the string to convert chunks of characters into the correct tokens.

The lexer will produce tokens of the following OCaml datatype:
\begincode
type token =
  NEWLINE | INDENT | DEDENT | EOF
| ID of string  (* identifier *)
| INT of int
| FLOAT of float
| STR of string
| IF | WHILE (* other keywords... *)
| (* operators and delimiters *)
\endcode
In OPythn, the amount of leading whitespace at the beginning of a line indicates the indentation level of the line. A tab character counts for exactly four spaces during this computation. Indentation levels of consecutive lines are used to generate {\tt INDENT} and {\tt DEDENT} tokens. This is done by means of a stack using the following algorithm, as described by the standard Python reference [1].

\bigskip
\centerline{{\bf Algorithm 1.} Insertion of {\tt INDENT} and {\tt DEDENT} tokens (as part of general lexing procedure)}
\begintext\parindent=0pt
{\it 01}\tab\Procedure{\sc lex}\kern2pt(OPythn source code) \Begin
{\it 02}\tab\tab${\it token\_list} \gets$ create a new empty list;
{\it 03}\tab\tab${\it stack} \gets$ create a new empty stack;
{\it 04}\tab\tab${\it stack.push}(0)$;
{\it 05}\tab\tab\While{there are lines to be read} \Do
{\it 06}\tab\tab\tab${\it line} \gets$ the current line;
{\it 07}\tab\tab\tab${\it num\_sp} \gets$ the number of leading spaces in ${\it line}$;
{\it 08}\tab\tab\tab\If${\it curr} > {\it stack.peek}()$ \Then
{\it 09}\tab\tab\tab\tab${\it stack.push}(curr)$;
{\it 10}\tab\tab\tab\tab${\it token\_list.add}({\tt INDENT})$;
{\it 11}\tab\tab\tab\ElsIf${\it curr} < {\it stack.peek}()$ \Then
{\it 12}\tab\tab\tab\tab${\it count}\gets 0$;
{\it 13}\tab\tab\tab\tab\While${\it curr} < {\it stack.peek}()$ \Do
{\it 14}\tab\tab\tab\tab\tab${\it stack.pop}()$;
{\it 15}\tab\tab\tab\tab\tab${\it count}\gets {\it count} + 1$;
{\it 16}\tab\tab\tab\tab\EndWhile
{\it 17}\tab\tab\tab\tab\For$i\gets 0$, ${\it count}$ \Do
{\it 18}\tab\tab\tab\tab\tab${\it token\_list.add}({\tt DEDENT})$;
{\it 19}\tab\tab\tab\tab\EndFor
{\it 20}\tab\tab\tab\EndIf
{\it 21}\tab\tab tokenise the rest of the line and add tokens to ${\it token\_list}$;
{\it 22}\tab\tab\EndWhile
{\it 23}\tab\tab\Return{${\it token\_list}$};
{\it 24}\tab\EndProcedure
\endtext

\section 4.2. Parsing

The tokens produced by the lexer is then fed into the parser, which will be implemented according to the grammar rules outlined in the appendix and using {\tt menhir}, an OCaml parser generator. The result will be an abstract syntax tree that represents the structure and semantics of the OPythn program. This tree is represented in the datatypes {\tt Ast.op}, {\tt Ast.expr}, and {\tt Ast.stmt}, which represent operations, expressions, and statements respectively.

\section 4.3. Bytecode

The abstract syntax tree is passed to the bytecode compiler, which produces instructions for a virtual stack machine, represented as the {\tt Instr.t} datatype. Some instructions, such as {\tt NOP} and {\tt BINARY\_ADD}, take no arguments, while others take one or several arguments. To resolve the scope of user-defined names, the compiler makes two passes through its input. During the first pass, every identifier is assigned a tag indicating the level at which it is defined. This allows the second pass to produce the correct {\tt STORE} and {\tt LOAD} instructions for each name.

\section 4.4. Virtual machine

The bytecode interpreter receives as input a {\tt DynArray}\footnote{$^1$}{From the {\tt extlib} library.} of {\tt Instr.t}. At the beginning of execution, the program counter is initialised to 0 and the stack is empty. Various hashtables hold the variable bindings of different scopes. When interpretation begins, a ``global'' hashtable is initialised to empty and a ``built-in'' hashtable contains all of the standard OPythn methods and functions. A separate list of hashtables is maintained for function closures. The head element of this list contains all local variable bindings and the subsequent hashtables contain the bindings of the enclosing scopes.

During each iteration of the execution loop, the instruction at the index of the program counter is read and executed. Most instructions modify the stack in some way; a notable exception is the family of jump instructions, which modify the program counter instead. If the program counter is not explicitly set, it is incremented before the next iteration. When the program counter exceeds the bounds of the instruction array, the program halts.

The stack holds typed OPythn values of the following mutually recursive datatypes, defined in the {\tt Py\_val} module. Tuples can be represented as simple arrays; however, since an OPythn list may be mutated, it is more naturally implemented as a {\tt DynArray}. To represent a dictionary, we use OCaml's {\tt Hashtbl} module. Finally, the ``sequence'' is OPythn's way of dealing with iteration and lazy lists and it is relies on OCaml's native {\tt Seq} module.
\begincode
type cls = {
\ \ name : string;
\ \ super : cls option;
\ \ attrs : (string, t) Hashtbl.t;
}
and obj = {
\ \ cls : cls;
\ \ fields : (string, t) Hashtbl.t;
}
and t =
\ \ Int of int
| Float of float
| Bool of bool
| Str of string
| Fun of string * (t list -> t)
| Obj of obj
| Class of cls
| Type of string
| List of t DynArray.t
| Tuple of t array
| Dict of (t, t) Hashtbl.t
| Seq of t Seq.t
| None
\endcode

\section 4.5. A simple example

The reader may find it enlightening to study how OPythn interprets the following snippet of code, which multiplies two integers:
\begincode
x = int(input("Enter the multiplicand: "))
y = int(input("Enter the multiplier: "))
acc = 0
while y > 0:
\tab if y \% 2 == 0:
\tab\tab x *= 2
\tab\tab y //= 2
\tab else:
\tab\tab acc += x
\tab\tab y -= 1
\endcode
The lexer reads the input and splits it into the following tokens.
\begincode
START\_FILE
(ID "x") ASSIG (ID "int") LPAREN (ID "input") LPAREN
\tab(STR "Enter the multiplicand: ") RPAREN RPAREN NEWLINE
(ID "y") ASSIG (ID "int") LPAREN (ID "input") LPAREN
\tab(STR "Enter the multiplier: ") RPAREN RPAREN NEWLINE
(ID "acc") ASSIG (INT 0) NEWLINE
WHILE (ID "y") GT (INT 0) COLON NEWLINE
INDENT IF (ID "y") MOD (INT 2) EQ (INT 0) COLON NEWLINE
INDENT (ID "x") TIMES\_A (INT 2) NEWLINE
(ID "y") INT\_DIV\_A (INT 2) NEWLINE
DEDENT ELSE COLON NEWLINE
INDENT (ID "acc") PLUS\_A (ID "x") NEWLINE
(ID "y") MINUS\_A (INT 1) NEWLINE
DEDENT DEDENT (ID "print") LPAREN
\tab(STR "The product is:") COMMA (ID "acc") RPAREN NEWLINE
EOF
\endcode
Next, the parser builds an abstract syntax tree that represents the structure of the program.
\begincode
[(Assign ((Var "x"),
\    (Call ((Var "int"),
\       [(Call ((Var "input"),
\        [(StrLit "Enter the multiplicand: ")]))]))
\    ));
\  (Assign ((Var "y"),
\     (Call ((Var "int"),
\        [(Call ((Var "input"),
\         [(StrLit "Enter the multiplier: ")]))]))
\     ));
\  (Assign ((Var "acc"), (IntLit 0)));
\  (While ((Op (Gt, [(Var "y"); (IntLit 0)])),
\     [(If ((Op (Eq, [(Op (Mod, [(Var "y"); (IntLit 2)]));
\                     (IntLit 0)])),
\         [(Assign ((Var "x"),
\                   (Op (Times, [(Var "x"); (IntLit 2)]))));
\           (Assign ((Var "y"),
\                    (Op (IntDiv, [(Var "y"); (IntLit 2)]))))],
\         (Some [(Assign ((Var "acc"),
\                         (Op (Plus, [(Var "acc"); (Var "x")]))));
\                 (Assign ((Var "y"),
\                          (Op (Minus, [(Var "y"); (IntLit 1)]))))])
\         ))
\       ]
\     ));
\  (Expr (Call ((Var "print"),
\         [(StrLit "The product is:"); (Var "acc")])))]
\endcode
The bytecode compiler walks the tree twice, first resolving the scope of each identifier (in this example, all identifiers are either built-in or global) before producing the actual instruction array.
\begincode
0        LOAD\_GLOBAL              "int"
1        LOAD\_GLOBAL              "input"
2        LOAD\_CONST               (Str "Enter the multiplicand: ")
3        CALL\_FUNCTION            1
4        CALL\_FUNCTION            1
5        STORE\_GLOBAL             "x"
6        LOAD\_GLOBAL              "int"
7        LOAD\_GLOBAL              "input"
8        LOAD\_CONST               (Str "Enter the multiplier: ")
9        CALL\_FUNCTION            1
10       CALL\_FUNCTION            1
11       STORE\_GLOBAL             "y"
12       LOAD\_CONST               (Int 0)
13       STORE\_GLOBAL             "acc"
14       LOAD\_GLOBAL              "y"
15       LOAD\_CONST               (Int 0)
16       COMPARE\_GT
17       POP\_JUMP\_IF\_FALSE        42
18       LOAD\_GLOBAL              "y"
19       LOAD\_CONST               (Int 2)
20       BINARY\_MOD
21       LOAD\_CONST               (Int 0)
22       COMPARE\_EQ
23       POP\_JUMP\_IF\_FALSE        33
24       LOAD\_GLOBAL              "x"
25       LOAD\_CONST               (Int 2)
26       BINARY\_MULT
27       STORE\_GLOBAL             "x"
28       LOAD\_GLOBAL              "y"
29       LOAD\_CONST               (Int 2)
30       BINARY\_INT\_DIV
31       STORE\_GLOBAL             "y"
32       JUMP                     41
33       LOAD\_GLOBAL              "acc"
34       LOAD\_GLOBAL              "x"
35       BINARY\_ADD
36       STORE\_GLOBAL             "acc"
37       LOAD\_GLOBAL              "y"
38       LOAD\_CONST               (Int 1)
39       BINARY\_SUB
40       STORE\_GLOBAL             "y"
41       JUMP                     14
42       LOAD\_GLOBAL              "print"
43       LOAD\_CONST               (Str "The product is:")
44       LOAD\_GLOBAL              "acc"
45       CALL\_FUNCTION            2
46       POP\_TOP
47       LOAD\_CONST               None
48       RETURN\_VALUE
\endcode
Finally, the bytecode is interpreted and the specified behaviour is produced in the terminal:
\begincode
Enter the multiplicand: 23
Enter the multiplier: 98
The product is: 2254
\endcode

\advsect GRAMMAR

This is the complete OPythn grammar specification. The structure borrows heavily from Python's grammar [1]. For brevity, the AST nodes that each rule produces have been omitted. These details may be found in the full working grammar, defined in {\tt src/parser.mly}
\begincode
(* Input *)
input: START\_FILE file\_input | START\_REPL repl\_input
file\_input: stmt* EOF
repl\_input: NEWLINE | EOF | simple\_stmt | compound\_stmt NEWLINE
\endcode
\begincode
(* Statements *)
stmt: simple\_stmt | compound\_stmt
simple\_stmt: small\_stmts SEMIC? NEWLINE
small\_stmts: small\_stmt | small\_stmts SEMIC small\_stmt
small\_stmt:
\ \ expr\_stmt | flow\_stmt | global\_stmt
| nonlocal\_stmt | pass\_stmt | del\_stmt
flow\_stmt: BREAK | CONTINUE | return\_stmt
pass\_stmt: PASS
compound\_stmt:
\ \ if\_stmt | while\_stmt | for\_stmt
| funcdef | classdef
condition: expr | cond\_expr
else\_clause: ELSE COLON suite
if\_stmt: IF condition COLON suite elif\_stmt* else\_clause?
elif\_stmt: ELIF condition COLON suite
while\_stmt: WHILE condition COLON suite
for\_stmt: FOR ID IN expr COLON suite
suite: deep\_suite
deep\_suite:
\ \ simple\_stmt NEWLINE
| NEWLINE INDENT stmt+ DEDENT
assig\_target: ID | attributeref | subscription
assignment\_stmt: assig\_target ASSIG assignable\_expr
aug\_assign: assig\_target bin\_op\_aug expr
expr\_stmt: expr | cond\_expr | assignment\_stmt | aug\_assign
del\_stmt: DEL expr
return\_stmt: RETURN assignable\_expr?
global\_stmt: GLOBAL ID
nonlocal\_stmt: NONLOCAL ID
\endcode
\begincode
(* Expressions *)
assignable\_expr: expr | cond\_expr
cond\_expr: expr IF expr ELSE assignable\_expr
comp\_op:
\ \ LT  | GT | EQ | LEQ | GEQ | NEQ 
| IN | NOT\_IN | IS | IS\_NOT
bin\_op\_aug:
\ \ BW\_OR\_A | BW\_XOR\_A  | BW\_AND\_A | LSHIFT\_A | RSHIFT\_A  | PLUS\_A
| MINUS\_A | TIMES\_A | FP\_DIV\_A | INT\_DIV\_A | MOD\_A | EXP\_A
slice: COLON expr
subscription: expr LSQUARE expr slice? RSQUARE
expr:
\ \ atom | call | attributeref | subscription
| expr BW\_OR expr | expr BW\_XOR expr | expr BW\_AND expr
| expr LSHIFT expr | expr RSHIFT expr | expr PLUS expr
| expr MINUS expr | expr TIMES expr | expr FP\_DIV expr
| expr INT\_DIV expr | expr MOD expr | expr EXP expr
| MINUS expr | BW\_COMP expr
| expr OR expr | expr AND expr | NOT expr
| expr comp\_op expr | LPAREN expr RPAREN
| LAMBDA param\_id\_list COLON expr
attributeref: expr DOT ID
key\_datum: expr COLON expr
key\_datum\_list: key\_datum | key\_datum COMMA key\_datum\_list
tuple\_list: expr COMMA expr | expr COMMA tuple\_list
atom:
\ \ ID | INT | FLOAT | STR | TRUE | FALSE | NONE
| LPAREN RPAREN | LPAREN expr COMMA RPAREN
| LPAREN tuple\_list RPAREN | LSQUARE argument\_list? RSQUARE
| LCURLY key\_datum\_list? RCURLY
call: expr LPAREN argument\_list? RPAREN
argument\_list: expr | expr COMMA argument\_list
\endcode
\begincode
(* Function and class definitions *)
funcdef: DEF ID LPAREN param\_id\_list? RPAREN COLON suite
classdef: CLASS ID class\_params? COLON suite
param\_id\_list: ID | ID COMMA param\_id\_list
class\_params: LPAREN RPAREN | LPAREN ID RPAREN
\endcode

\section REFERENCES
\frenchspacing

\item{[1]} Guido van Rossum, {\sl The Python Language Reference} (Python Software Foundation, 2019).

\bye
